<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Class Loader Sub System: </title>
<link rel="stylesheet"
	href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script
	src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script
	src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<style type="text/css">
</style>
</head>
<body>
   <h4>
       <b style="color: green ">Class Loader Sub System:</b>
	</h4>
	<ul>
	 <li>Class loader sub system is responsible for this following 3 activities . 
	    <ul>
	      <li>Loading</li>
	      <li>Linking</li>
	      <li>Initialization</li>
	    </ul>
	 </li>
	</ul>
	<h5>
       <b style="color: green ">Loading:</b>
	</h5>
	<ul>
	  <li>Loading means reading class files and store corresponding binary data in method area . </li>
	  <li>For each class, file JVM will store the following information in Method Area . 
	    <ul>
	      <li>Fully qualified name of component(class|interface|enum)</li>
	      <li>Fully qualified name of parent (class|interface|enum)</li>
	      <li>Is .class file related to class|interface|enum </li>
	      <li>Modifiers information </li>
	      <li>Methods information</li>
	      <li>Variables|Fields information</li>
	      <li>Constant Pool .(How many constants are there related to this class)</li>
	    </ul>
	  </li>
	  <li>After loading .class file JVM creates an object for that loaded class on the Heap memory with type java.lang.Class(i.e JVM create class Class objecy for every .class file)</li>
	</ul>
	<img alt="" src="images/JVMClassLoad.PNG">
	<ul>
	 <li>By using this class object programmer can get corresponding class information like its name, its parent name, constructors information, methods information, fields information etc . </li>
	</ul>
	<textarea rows="5" cols="80" style="color: blue;">
	       Example:
	                String s = new String("AG");
	                System.out.println(s.getClass().getName());
	             o/p: java.lang.String
	</textarea>
	<textarea rows="25" cols="80" style="color: blue;">
	       Example:
	               import java.lang.reflect.*;
	               class Student { 
	                 public String getName(){ 
	                   return null;
	                 }
	                 public int getMarks(){ 
	                   return 10;
	                 }
	               }
	               
	               class Test { 
	                  public static void main(String[] args) {
	                     int count = 0;
	                     Class c = Class.forName("Student");
	                     Method[] m = c.getDeclaredMethods();
	                     for(Method m1:m){ 
	                       count++;
	                       System.out.println(m1.getName());
	                     }
	                     System.out.println(count);
	                  }
	               }
	</textarea>
	<h5>
       <b style="color: green ">Linking:</b>
	</h5>
	<ul>
	  <li>Linking consists of the following 3 activities 
	    <ul>
	      <li>Verification</li>
	      <li>Preparation</li>
	      <li>Resolution</li>
	    </ul>
	  </li>
	</ul>
	<h6>
       <b style="color: green ">Verification:</b>
	</h6>
	<ul>
	  <li>It is the process of ensuring that binary representation of a class is structurally current or not i.e , JVM will check whether the class file generated by valid compiler not and whether class file properly formatted or not . </li>
	  <li>Internally Bytecode verifier is responsible for this activity . </li>
	  <li>Bytecode verifier is the part of class loader sub system . </li>
	  <li>If verification fails then we will get RuntimeException : saying : java.lang.VerifyError . </li>
	</ul>
	<h6>
       <b style="color: green ">Preparation:</b>
	</h6>
	<ul>
	 <li>In this phase, JVM will allocate memory for class level static variables and assign default values(but not original values assigned to that variables)</li>
	 <li>Note: Original values won't be assigned until initialization phase . </li>
	</ul>
	<h6>
       <b style="color: green ">Resolution:</b>
	</h6>
	<ul>
	  <li>It is the process of replacing symbolic names used located type with original references . </li>
	  <li>Symbolic references are resolved into direct references by searching through Method Area to locate the reference entity . </li>
	</ul>
	<textarea rows="5" cols="80" style="color: blue;">
	       Example:
	                class Test {
	                   public static void main(String[] args){ 
	                      String s1 = new String("AG");
	                      Student st = new Stident();  
	                   }
	                }
	</textarea>
	<ul>
	  <li>For the above class, class loader loads Test.class, String.class, Student.class and Object.class .</li>
	  <li>The names of these classes are Stored in Constant pool of Test class . </li>
	  <li>In Resolution phase, these names are replaced with actual references from Method Area . </li>
	</ul>
	<h5>
       <b style="color: green ">Initialization:</b>
	</h5>
	<ul>
	  <li>In this phase, all static variables will be assigned with original values and static blocks will be executed from parent to child from top to bottom . </li>
	</ul>
	<img alt="" src="images/Initialization.PNG">
	<ul>
	  <li>Note: While Loading, Linking and Initialization if any error occurs then we will get Runtime Exception : saying java.lang.LinkageError . </li>
	</ul>
	
	 <h4>
       <b style="color: green ">Types of ClassLoader :</b>
	</h4>
	<ul>
	 <li>Every class loader subsystem contains the following 3 class loaders . 
	     <ul>
	       <li>Bootstrap class loader </li>
	       <li>Extension class loader </li>
	       <li>Application class loader </li>
	     </ul>
	 </li>
	</ul>
	 <h5>
       <b style="color: green ">Bootstrap class loader :</b>
	</h5>
	<ul>
	  <li>This class loader is responsible for loading core java API classes i.e the classes present in rt.jar file . </li>
	  <li>This location is called Bootstrap class path i.e , Bootstrap class loader is responsible for to load classes from Bootstrap class path . </li>
	  <li>Bootstrap class loader by default available in JVM and it is implemented Bootstrap class path . </li>
	</ul>
	 <h5>
       <b style="color: green ">Extension Class Loader :</b>
	</h5>
	<ul>
	  <li>The class loader is the child of Bootstrap class loader . </li>
	  <li>This class loader is responsible for to load class from extension class path(JDE\JRE\lib\ext) . </li>
	  <li>This class loader is implemented in java and the corresponding .class file name is sun.misc.Launcher$AppClassLoader.class .</li>
	</ul>
	 <h5>
       <b style="color: green ">Application class loader :</b>
	</h5>
	<ul>
	  <li>It is the child of Extension class loader .</li>
	  <li>It is responsible for to load classes from Application classpath</li>
	  <li>It is internally uses environment variable classpath . </li>
	  <li>It is internally implemented in java by SUN people and the corresponding .class the file name is sun.misc.Launcher$AppClassLoader.class .</li>
	</ul>
	<h5>
       <b style="color: green ">How class Loader works ?</b>
	</h5>
	<ul>
	 <li>Class loader follows Delegation Hierarchy principle . </li>
	 <li>Whenever JVM come across a particular class first it will check the corresponding class is already loaded or not . </li>
	 <li>If it is already loaded in Method area then JVM will use that loaded class . </li>
	 <li>If it is not already loaded then JVM requires class loader subsystem to load the particular class then class loader subsystem handovers the request to Application Class Loader . </li>
	 <li>Application class loader delegates request to Extension Class Loader and Extension Class Loader intern delegates that request to Bootstrap Class Loader . </li>
	 <li>Bootstrap Class Loader searches in Bootstrap class path(JDK\JRE\lib\rt.jar)</li>
	 <li>If the specified class is available then it will be loaded , otherwise Bootstrap Class Loader delegates the request to Extension Class Loader . </li>
	 <li>Extension Class Loader will search in Extension Class Path (JDK\JRE\lib\ext\*) .</li>
	 <li>If the required class is available then it will be loaded , otherwise Extension Class Loader delegates the request to Application Class Loader . </li>
	 <li>Application Class Loader will search in Application class path for the required .class file </li>
	 <li>If the specified class is available then it will be loaded , otherwise we will get Runtime Exception : saying , ClassNotFoundException (or) NoClassDefFoundError . </li>
	</ul>
	<img alt="" src="images/ClassLoaderArch.PNG">
	<textarea rows="15" cols="80" style="color: blue;">
	       Example:
	                class Test {
	                   public static void main(String[] args){ 
	                      System.out.println(String.class.getClassLoader());
	                      System.out.println(Student.class.getClassLoader());
	                      System.out.println(Test.class.getClassLoader());
	                   }
	                }
	         Note: Assume that Student.class present in Extension and Application class path and Test.class present only in Application class path
	       
	         For String.class : From Bootstrap class path by Bootstrap class Loader 
	         o/p: null
	         For Student.class : From Extension class path by Extension class Loader 
	         o/p: sun.misc.Launcher$ExtClassLoader@1234
	         For Test.class : From Application class path by Application Class Loader 
	         o/p: sun.misc.Launcher$AppClassLoader@4567
	         
	</textarea>
	<ul>
	 <li>Note: Bootstrap class loader is not Java object and hence we got for the first System.out.println is null, but Extension and Application class loaders are java objects and hence we are getting the proper output .(ClassName@hexadecimal String of hash code)</li>
	 <li>Class Loader subsystem will give highest priority for Bootstrap class path and then Extension class path followed by Application class path .</li>
	</ul>
	<h5>
       <b style="color: green ">What is the need of Customized class loader ?</b>
	</h5>
	<ul>
	  <li>Default Class Loader will load .class file only once eventhough we are using multiple times that class in our program . </li>
	  <li>After loading .class file if it is modified outside then default Class Loader won't load updated version of class file (because .class file already there in method area)</li>
	  <li>We can resolve this problem by defining our own class loader . </li>
	  <li>The main advantages of customized class loader is we can control class loading mechanism based on our requirement . </li>
	  <li>Ex: We can load class file separately every time , so that updated version available . </li>
	</ul>
	
	<img alt="" src="images/CustomizedClassLoader.PNG">
	
	<h5>
       <b style="color: green ">How to developed our own customized Class Loader ?</b>
	</h5>
	<ul>
	 <li>We can define our own Customized class loader while to customize class loading mechanism </li>
	 <li>We can define our own customized class loader by outstanding java.lang.ClassLoader`	</li>
	</ul>
	<textarea rows="15" cols="80" style="color: blue;">
	       Example:
	                 public class CustomizedClassLoader extends ClassLoader { 
	                    public Class loadClass(String name) throws ClassNotFoundException{ 
	                      // Read updated class file and returns it
	                    }
	                 }
	                 class Client { 
	                   public static void main(String[] args){ 
	                      AG a = new AG();
	                      CustomizedClassLoader c = new CustomizedClassLoader();
	                      c.loadClass("AG");
	                      
	                   }
	                 }
	</textarea>
	<ul>
	  <li>Note: Usually we can define our own customized class loader while developing web servers and application servers .  </li>
	</ul>
	
	<h5>
       <b style="color: green ">What is the purpose of java.lang.ClassLoader class ?</b>
	</h5>
	<ul>
	  <li>This class acts as base class for designing class loaders . Every customized class loader class should extend java.lang.ClassLoader either directly or indirectly . </li>
	</ul>
</body>
</html> 